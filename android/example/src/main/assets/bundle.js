/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/jdhybrid_jdbridge/JDBridge.js":
/*!****************************************************!*\
  !*** ./node_modules/jdhybrid_jdbridge/JDBridge.js ***!
  \****************************************************/
/***/ (() => {

eval("// \n// MIT License\n// \n// Copyright (c) 2022 JD.com, Inc.\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n//\n\n(function () {\n    if (window.JDBridge) {\n        return\n    };\n\n    const TAG = 'JDBridge: ';\n    // debug show logs\n    var debug = false;\n    // the queue waiting for js plugin to execute\n    var nativeRequestQueue = [];\n    // the js functions handle native requests\n    var jsPlugins = {};\n    // ths js callbacks invoked after js calls native\n    var responseCallbacks = {};\n    // an unique id for response callback\n    var uniqueId = 1;\n\n    function logE(msg){\n        if (debug) {\n            console.error(TAG + msg);\n        }\n    }\n\n    function logD(msg){\n        if (debug) {\n            console.log(TAG + msg);\n        }\n    }\n\n    function setDebug(isDebug){\n        debug = isDebug;\n    }\n\n    function isDebug(){\n        return debug;\n    }\n\n    // the API to set default plugin, then native can call js without plugin name or plugin has not registered\n    function registerDefaultPlugin(handler) {\n        logD('register a defualt js plugin');\n        if (handler && typeof handler != 'function') {\n            logE('cannot register a default plugin that is not a function');\n            return;\n        }\n        if (JDBridge._defaultPlugin) {\n            logD('old defualt js plugin has been changed')\n        };\n        JDBridge._defaultPlugin = handler;\n        if (nativeRequestQueue) {\n            logD('dispatch request from native in queue');\n            var reqQueue = nativeRequestQueue;\n            // forbid to queue after set default js plugin\n            nativeRequestQueue = null;\n            for (var i = 0; i < reqQueue.length; i++) {\n                logD('dispatch all request in queue: request = ' + JSON.stringify(reqQueue[i]));\n                _doHandleFromNative(reqQueue[i]);\n            }\n        }\n    };\n\n    // the API to add the js plugin that native can call\n    function registerPlugin(pluginName, handler) {\n        logD('register a js plugin: ' + pluginName);\n        if (!handler || typeof handler != 'function') {\n            logE('cannot register a js plugin: ' + pluginName + ', handle is ' + handler);\n            return;\n        }\n        jsPlugins[pluginName] = handler;\n        var reqQueue = nativeRequestQueue;\n        if (reqQueue && reqQueue.length > 0) {\n            logD('dispatch request from native that can be handled by ' + pluginName + ' in queue(size:' + reqQueue.length + ')');\n            for (var i = 0; i < reqQueue.length; i++) {\n                var request = reqQueue[i];\n                if (request.plugin && jsPlugins[request.plugin]) {\n                    nativeRequestQueue.splice(i--, 1);\n                    _doHandleFromNative(request);\n                }\n            }\n            logD('now the native request queue size: ' + nativeRequestQueue.length);\n        }\n    };\n\n    // the API to remove the js plugin\n    function unregisterPlugin(pluginName) {\n        logD('remove a js plugin: ' + pluginName);\n        delete jsPlugins[pluginName];\n    };\n\n    // the API to call native code\n    // can call like this: \n    //      callNative('pluginName')\n    //      callNative('pluginName', {action: 'yourAction', params: 'yourParams', success: function(), error: function(), progress: function()})\n    //      callNative({name: 'pulginName', action: 'yourAction', params: 'yourParams', success: function(), error: function(), progress: function()})\n    function callNative() {\n        if (!window.XWebView) {\n            logE('Error! No JDBridge native enviroment detected.');\n            return;\n        }\n        var callParams;\n        var pluginName, action, params, successFunc, errorFunc, progressFunc;\n        if (arguments.length == 1) {\n            var arg = arguments[0];\n            if (typeof arg == 'string') {\n                pluginName = arg;\n            } else {\n                callParams = arg;\n            }\n        } else if (arguments.length == 2) {\n            pluginName = arguments[0];\n            callParams = arguments[1];\n        }\n        if (callParams) {\n            if (callParams.name) {\n                pluginName = callParams.name;\n            }\n            action = callParams.action;\n            params = callParams.params;\n            successFunc = callParams.success;\n            errorFunc = callParams.error;\n            progressFunc = callParams.progress;\n        }\n        logD('callNative -> pluginName:' + pluginName + ', action:' + action + ', params:' + params + ', successFunc:' + successFunc + ', errorFunc:' + errorFunc + ', progressFunc:' + progressFunc);\n        if (pluginName && typeof pluginName != 'string') {\n            logE('Error! Plugin\\'s name provided must be a string.');\n            return;\n        }\n        var callbackId;\n        if (successFunc) {\n            if (typeof successFunc == 'function') {\n                callbackId = 'cb_' + (uniqueId++) + '_' + new Date().getTime();\n                var callbacks = {};\n                responseCallbacks[callbackId] = callbacks;\n                callbacks.successFunc = successFunc;\n                if (errorFunc) {\n                    if (typeof errorFunc == 'function') {\n                        callbacks.errorFunc = errorFunc;\n                    } else {\n                        logE('Error! Error callback is not a function.');\n                    }\n                }\n                if (progressFunc) {\n                    if (typeof progressFunc == 'function') {\n                        callbacks.progressFunc = progressFunc;\n                    } else {\n                        logE('Error! Progress callback is not a function.');\n                    }\n                }\n            } else {\n                logE('Error! Success callback is not a function.');\n                return;\n            }\n        }\n        var request = {\n            plugin: pluginName ? pluginName : '',\n            action: action ? action : '',\n            params: params,\n            callbackId: callbackId\n        };\n        window.XWebView._callNative(JSON.stringify(request));\n    };\n\n    // actual work that processing message from native.\n    // will check if there is plugin can handle, if no default plugin and named plugin found, then nothing happens.\n    function _doHandleFromNative(request) {\n        setTimeout(function () {\n            if (!window.XWebView) {\n                logE('Error! No JDBridge native enviroment detected.');\n                return;\n            }\n            var plugin;\n            if (request.plugin) {\n                plugin = jsPlugins[request.plugin];\n            }\n            if (!plugin) {\n                // can use default plugin if no specific plugin registered\n                plugin = JDBridge._defaultPlugin;\n            }\n            if (plugin) {\n                var jsCallback;\n                if (request.callbackId) {\n                    var callbackId = request.callbackId;\n                    logD('request.callbackId = ' + callbackId);\n                    jsCallback = function (result, success, complete) {\n                        if (typeof success != 'boolean' || typeof success == 'undefined') {\n                            success = true;\n                        }\n                        if (typeof complete != 'boolean' || typeof complete == 'undefined') {\n                            complete = true;\n                        }\n                        var response = {\n                            callbackId: callbackId,\n                            complete: complete\n                        };\n                        if (success) {\n                            response.status = '0';\n                            response.data = result;\n                        } else {\n                            response.status = '-1';\n                            response.msg = result;\n                        }\n                        logD('response to native: ' + JSON.stringify(response));\n                        // window.XWebView._respondFromJs(JSON.stringify(response));\n                        var request = {\n                            plugin: '_jdbridge',\n                            action: '_respondFromJs',\n                            params: response,\n                        };\n                        window.XWebView._callNative(JSON.stringify(request));\n                    }\n                }\n                try {\n                    // If the function has more than 2 arguements, then it need a callback\n                    if (plugin.length >= 2) {\n                        // js async call\n                        logD('call js async plugin');\n                        plugin.call(this, request.params, jsCallback);\n                    } else {\n                        // js sync call\n                        logD('call js sync plugin');\n                        var result = plugin.call(this, request.params);\n                        if (jsCallback) {\n                            jsCallback(result, true, true);\n                        }\n                    }\n                } catch (exception) {\n                    logE(\"javascript plugin threw. \", request.plugin, exception);\n                }\n            } else {\n                logD('no plugin to handle request:' + request.plugin);\n            }\n        });\n    };\n\n    // invoked by native, may queue and wait for js registering if there is no plugin can process this request.\n    function _handleRequestFromNative(requestJSON) {\n        logD('handle request from native: ' + requestJSON);\n        var request = JSON.parse(requestJSON);\n        if (!JDBridge._defaultPlugin) {\n            // no default plugin registered\n            if (request.plugin && !jsPlugins[request.plugin]) {\n                // add this request into queue because there is no plugin can handle,\n                // wait for js registering plugin.\n                logD('cannot find plugin to handle this request[' + request.plugin + '], will wait for js adding this plugin.');\n                nativeRequestQueue.push(request);\n                return;\n            }\n        }\n        // try to handle request, will check if there is plugin can handle,\n        // if no default plugin and named plugin found, then nothing happens.\n        _doHandleFromNative(request);\n    };\n\n    // invoked by native, receive response from native after native is called by js\n    function _handleResponseFromNative(responseJSON) {\n        logD('handle response from native: ' + responseJSON);\n        var response = JSON.parse(responseJSON);\n        if (response.callbackId) {\n            var callback = responseCallbacks[response.callbackId];\n            if (!callback) {\n                logD('cannot find the callback: ' + response.callbackId);\n                return;\n            }\n            if (response.status == '0') {\n                if (response.complete == false) {\n                    if (!callback.progressFunc) {\n                        logD('cannot find the progress callback: ' + response.callbackId);\n                    } else {\n                        callback.progressFunc(response.data, response);\n                    }\n                } else {\n                    if (!callback.successFunc) {\n                        logD('cannot find the success callback: ' + response.callbackId);\n                    } else {\n                        callback.successFunc(response.data, response);\n                    }\n                }\n            } else {\n                if (!callback.errorFunc) {\n                    logD('cannot find the error callback: ' + response.callbackId);\n                } else {\n                    callback.errorFunc(response.msg, response);\n                }\n            }\n            if (response.complete == false) {\n                logD('response from native is not completed, continue to hold callback: ' + response.callbackId);\n            } else {\n                delete responseCallbacks[response.callbackId];\n            }\n        }\n    };\n\n    // function _handleNativeDispatchEvent(eventName, params) {\n    //     logD('dispatchEvent [' + eventName + '], params = ' + params);\n    //     if (!eventName) {\n    //         return;\n    //     }\n    //     var myEvent = new CustomEvent(eventName, { params: params });\n    //     document.dispatchEvent(myEvent);\n    // };\n\n    function nativeReady(){\n        return typeof window.XWebView != 'undefined';\n    }\n\n    //methods that web can call\n    var JDBridge = window.JDBridge = {\n        registerDefaultPlugin: registerDefaultPlugin,\n        registerPlugin: registerPlugin,\n        unregisterPlugin: unregisterPlugin,\n        callNative: callNative,\n        _handleRequestFromNative: _handleRequestFromNative,\n        _handleResponseFromNative: _handleResponseFromNative,\n        nativeReady: nativeReady,\n        setDebug: setDebug,\n        isDebug: isDebug\n        // _handleNativeDispatchEvent: _handleNativeDispatchEvent\n    };\n\n    if (!window._jdbridgeInit) {\n        // notify web that JDBridge completed initialization.\n        logD('dispatchEvent JDBridgeReady');\n        var readyEvent = new CustomEvent(\"JDBridgeReady\", { detail: { bridge: JDBridge } });\n        window.dispatchEvent(readyEvent);\n        // notify native that this js kit completed initialization.\n        window._jdbridgeInit = true;\n        setTimeout(function () {\n            if (!window.XWebView) {\n                logE('Error! No JDBridge native enviroment detected.');\n                return;\n            };\n            // window.XWebView && window.XWebView._jsInit();\n            var request = {\n                plugin: '_jdbridge',\n                action: '_jsInit'\n            };\n            window.XWebView._callNative(JSON.stringify(request));\n            logD('JDBridge is Ready.');\n        });\n    };\n\n\n})()\n\n\n//# sourceURL=webpack://npmtest/./node_modules/jdhybrid_jdbridge/JDBridge.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("// \n// MIT License\n// \n// Copyright (c) 2022 JD.com, Inc.\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n//\nvar JDBridge = __webpack_require__(/*! jdhybrid_jdbridge */ \"./node_modules/jdhybrid_jdbridge/JDBridge.js\")\n\n//# sourceURL=webpack://npmtest/./src/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;